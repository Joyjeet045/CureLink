<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Consultation</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.0.0/mdb.min.css" rel="stylesheet" />
    <style>
        body { background: #f8f9fa; font-family: 'Roboto', sans-serif; }
        .video-container { display: flex; flex-direction: row; justify-content: space-between; align-items: flex-start; margin-top: 40px; }
        .video-box { background: #fff; border-radius: 16px; box-shadow: 0 2px 16px rgba(0,0,0,0.08); padding: 24px; width: 60%; display: flex; flex-direction: column; align-items: center; }
        .video-box video { width: 100%; border-radius: 12px; background: #222; }
        .video-label { 
            font-size: 14px; 
            font-weight: 500; 
            color: #666; 
            margin-bottom: 8px; 
            text-align: center; 
        }

        .chat-box { background: #fff; border-radius: 16px; box-shadow: 0 2px 16px rgba(0,0,0,0.08); padding: 24px; width: 35%; display: flex; flex-direction: column; height: 500px; }
        .chat-messages { flex: 1; overflow-y: auto; margin-bottom: 16px; display: flex; flex-direction: column; }
        .chat-bubble {
            max-width: 75%;
            padding: 10px 16px;
            border-radius: 18px;
            margin-bottom: 8px;
            font-size: 15px;
            word-break: break-word;
            display: inline-block;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.07);
        }
        .chat-bubble.sender {
            background: linear-gradient(135deg, #e3f2fd, #bbdefb);
            align-self: flex-end;
            border-bottom-right-radius: 4px;
            margin-left: auto;
            text-align: right;
        }
        .chat-bubble.receiver {
            background: linear-gradient(135deg, #f1f8e9, #c8e6c9);
            align-self: flex-start;
            border-bottom-left-radius: 4px;
            margin-right: auto;
            text-align: left;
        }
        .chat-meta {
            font-size: 11px;
            color: #888;
            margin-top: 2px;
            text-align: right;
        }
        .chat-input { display: flex; }
        .chat-input input { flex: 1; border-radius: 8px 0 0 8px; border: 1px solid #ddd; padding: 8px; }
        .chat-input button { border-radius: 0 8px 8px 0; border: none; background: #007bff; color: #fff; padding: 8px 16px; }
        .status-bar { text-align: center; margin-bottom: 16px; color: #28a745; font-weight: 500; }
    </style>
</head>
<body>
    <div class="container video-container">
        <div class="video-box">
            <h4>Video Consultation</h4>
            {% if appointment %}
                <div class="alert alert-info">
                    {% if user.profile.role == 'doctor' %}
                        <b>Patient:</b> {{ appointment.patient.first_name }} {{ appointment.patient.last_name }}<br>
                        <b>Status:</b> 
                        {% if appointment.status == 'pending' %}
                            <span class="badge bg-warning">Waiting for doctor</span>
                        {% elif appointment.status == 'active' %}
                            <span class="badge bg-success">Active</span>
                        {% else %}
                            <span class="badge bg-secondary">Ended</span>
                        {% endif %}
                    {% else %}
                        <b>Doctor:</b> 
                        {% if appointment.doctor %}
                            Dr. {{ appointment.doctor.get_name }}
                        {% else %}
                            <span class="text-muted">Waiting for doctor to join...</span>
                        {% endif %}
                        <br>
                        <b>Status:</b> 
                        {% if appointment.status == 'pending' %}
                            <span class="badge bg-warning">Waiting for doctor</span>
                        {% elif appointment.status == 'active' %}
                            <span class="badge bg-success">Active</span>
                        {% else %}
                            <span class="badge bg-secondary">Ended</span>
                        {% endif %}
                    {% endif %}
                    <br>
                    <b>Room ID:</b> {{ room_id }}
                </div>
            {% endif %}
            <div class="video-label">{% if user.profile.role == 'doctor' %}Doctor (You){% else %}Patient (You){% endif %}</div>
            <video id="localVideo" autoplay muted playsinline></video>
            <div class="video-label" style="margin-top: 16px;">{% if user.profile.role == 'doctor' %}Patient{% else %}Doctor{% endif %}</div>
            <video id="remoteVideo" autoplay playsinline style="margin-top: 8px;"></video>
            <div class="status-bar" id="connectionStatus">Connecting...</div>
            
            <!-- Test Mode Controls (only show on localhost) -->
            {% if request.get_host == 'localhost:8000' or request.get_host == '127.0.0.1:8000' %}
            <div class="d-flex justify-content-center mt-2 mb-3">
                <button class="btn btn-warning btn-sm mx-2" id="testModeBtn">
                    <i class="fas fa-video"></i> Enable Test Mode
                </button>
                <div class="form-check">
                    <input class="form-check-input" type="checkbox" id="testModeCheck">
                    <label class="form-check-label" for="testModeCheck">
                        Single Device Test
                    </label>
                </div>
            </div>
            {% endif %}
            
            <div class="d-flex justify-content-center mt-3">
                <button class="btn btn-danger mx-2" id="endCallBtn"><i class="fas fa-phone-slash"></i> End Call</button>
            </div>
        </div>
        <div class="chat-box">
            <h5>Chat</h5>
            <div class="chat-messages" id="chatMessages"></div>
            <form class="chat-input" id="chatForm" autocomplete="off">
                <input type="text" id="chatInput" placeholder="Type a message..." required />
                <button type="submit"><i class="fas fa-paper-plane"></i></button>
            </form>
        </div>
    </div>
    <script>
        // --- WebRTC and WebSocket signaling logic ---
        const roomName = "{{ room_id|escapejs }}";
        const wsScheme = window.location.protocol === "https:" ? "wss" : "ws";
        const signalingSocket = new WebSocket(
            wsScheme + '://' + window.location.host + '/ws/video/' + roomName + '/'
        );
        const chatSocket = new WebSocket(
            wsScheme + '://' + window.location.host + '/ws/chat/' + roomName + '/'
        );

        let localStream;
        let remoteStream;
        let peerConnection;
        const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const connectionStatus = document.getElementById('connectionStatus');

        let testModeEnabled = false;

        async function startLocalVideo() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                connectionStatus.textContent = 'Local video started. Waiting for connection...';
            } catch (e) {
                connectionStatus.textContent = 'Could not access camera/mic: ' + e;
            }
        }

        function enableTestMode() {
            if (localStream) {
                try {
                    // Create a new stream for the remote video
                    const remoteStream = new MediaStream();
                    localStream.getTracks().forEach(track => {
                        remoteStream.addTrack(track.clone());
                    });
                    remoteVideo.srcObject = remoteStream;
                    connectionStatus.textContent = 'Test mode enabled: Both videos show local stream';
                    testModeEnabled = true;
                } catch (cloneError) {
                    // Fallback: use the same stream
                    remoteVideo.srcObject = localStream;
                    connectionStatus.textContent = 'Test mode enabled: Using same stream for both videos';
                    testModeEnabled = true;
                }
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);
            peerConnection.onicecandidate = event => {
                if (event.candidate) {
                    signalingSocket.send(JSON.stringify({ 'candidate': event.candidate }));
                }
            };
            peerConnection.ontrack = event => {
                if (!remoteStream) {
                    remoteStream = new MediaStream();
                    remoteVideo.srcObject = remoteStream;
                }
                remoteStream.addTrack(event.track);
            };
            localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));
        }

        signalingSocket.onopen = () => {
            connectionStatus.textContent = 'Connected. Waiting for another participant...';
            startLocalVideo().then(() => {
                createPeerConnection();
            });
        };

        signalingSocket.onmessage = async (event) => {
            const data = JSON.parse(event.data);
            if (data.offer) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                signalingSocket.send(JSON.stringify({ 'answer': answer }));
                connectionStatus.textContent = 'In call';
            } else if (data.answer) {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                connectionStatus.textContent = 'In call';
            } else if (data.candidate) {
                try {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                } catch (e) {
                    console.error('Error adding received ice candidate', e);
                }
            } else if (data.ready) {
                // If another participant joins, create and send offer
                if (peerConnection.signalingState === 'stable') {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    signalingSocket.send(JSON.stringify({ 'offer': offer }));
                }
            }
        };

        signalingSocket.onclose = () => {
            connectionStatus.textContent = 'Connection closed.';
        };

        // Notify server when ready (for 2nd participant)
        signalingSocket.onopen = () => {
            connectionStatus.textContent = 'Connected. Waiting for another participant...';
            startLocalVideo().then(() => {
                createPeerConnection();
                signalingSocket.send(JSON.stringify({ 'ready': true }));
            });
        };

        // --- Real-time Chat Logic ---
        const chatForm = document.getElementById('chatForm');
        const chatInput = document.getElementById('chatInput');
        const chatMessages = document.getElementById('chatMessages');
        const currentUser = "{{ user.username|escapejs }}";

        chatForm.onsubmit = function(e) {
            e.preventDefault();
            const message = chatInput.value.trim();
            if (message) {
                chatSocket.send(JSON.stringify({ 'message': message, 'sender': currentUser }));
                chatInput.value = '';
            }
        };

        chatSocket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.message) {
                const msgDiv = document.createElement('div');
                // Determine if the message is from the current user
                const isSender = data.sender === currentUser;
                msgDiv.className = 'chat-bubble ' + (isSender ? 'sender' : 'receiver');
                msgDiv.innerHTML = `<span>${data.message}</span><div class="chat-meta">${isSender ? 'You' : data.sender || 'Other'}</div>`;
                chatMessages.appendChild(msgDiv);
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        };

        chatSocket.onopen = function() {
            // Optionally show chat connected status
        };
        chatSocket.onclose = function() {
            // Optionally show chat disconnected status
        };

        // Function to update appointment status display
        function updateAppointmentStatus() {
            fetch(`/get-appointment-status/{{ room_id }}/`)
                .then(response => response.json())
                .then(data => {
                    const statusElement = document.querySelector('.alert.alert-info');
                    if (statusElement) {
                        const isDoctor = {% if user.profile.role == 'doctor' %}true{% else %}false{% endif %};
                        let statusHtml = '';
                        
                        if (isDoctor) {
                            statusHtml = `
                                <b>Patient:</b> ${data.patient_name}<br>
                                <b>Status:</b> 
                                ${data.status === 'pending' ? '<span class="badge bg-warning">Waiting for doctor</span>' : 
                                  data.status === 'active' ? '<span class="badge bg-success">Active</span>' : 
                                  '<span class="badge bg-secondary">Ended</span>'}
                            `;
                        } else {
                            statusHtml = `
                                <b>Doctor:</b> 
                                ${data.doctor_name ? 'Dr. ' + data.doctor_name : '<span class="text-muted">Waiting for doctor to join...</span>'}<br>
                                <b>Status:</b> 
                                ${data.status === 'pending' ? '<span class="badge bg-warning">Waiting for doctor</span>' : 
                                  data.status === 'active' ? '<span class="badge bg-success">Active</span>' : 
                                  '<span class="badge bg-secondary">Ended</span>'}
                            `;
                        }
                        statusHtml += `<br><b>Room ID:</b> {{ room_id }}`;
                        statusElement.innerHTML = statusHtml;
                    }
                })
                .catch(error => console.error('Error updating status:', error));
        }

        // Update status every 2 seconds
        const statusInterval = setInterval(updateAppointmentStatus, 2000);

        // Test mode controls
        const testModeBtn = document.getElementById('testModeBtn');
        const testModeCheck = document.getElementById('testModeCheck');
        
        if (testModeBtn) {
            testModeBtn.onclick = function() {
                enableTestMode();
            };
        }
        
        if (testModeCheck) {
            testModeCheck.onchange = function() {
                if (this.checked) {
                    enableTestMode();
                } else {
                    // Disable test mode - clear remote video
                    remoteVideo.srcObject = null;
                    connectionStatus.textContent = 'Test mode disabled. Waiting for real connection...';
                    testModeEnabled = false;
                }
            };
        }

        document.getElementById('endCallBtn').onclick = function() {
            if (peerConnection) peerConnection.close();
            signalingSocket.close();
            chatSocket.close();
            clearInterval(statusInterval);
            
            // Update appointment status to ended
            fetch('/update-appointment-status/', {
                method: 'POST',
                headers: {
                    'X-CSRFToken': '{{ csrf_token }}',
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ 
                    appointment_id: '{{ room_id }}',
                    status: 'ended'
                })
            });
            
            window.close();
        };
    </script>
</body>
</html> 